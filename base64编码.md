原文地址:[Computer science in JavaScript: Base64 encoding](https://www.nczonline.net/blog/2009/12/08/computer-science-in-javascript-base64-encoding/)

不久前， 我写了关于[data URI](https://www.nczonline.net/blog/2009/10/27/data-uris-explained/)的博客并放出了一组创建他们的[工具](http://www.nczonline.net/blog/2009/11/03/automatic-data-uri-embedding-in-css-files/) 这其中的一个关键部分就是URI方程 － base64 编码。 Base64编码 在[RFC3548](http://tools.ietf.org/html/rfc3548)中与base16以及base32一起都有详细的描述。这些方式都被用作在有限的字符集中表示单字节数据。对于base64一个很常见的误解就是将其误认为是一种用来隐藏底层数据的加密(encryption)算法，实际上Base64编码（encoding）并不包含任何加密，它只是简单地将一个数据格式转换成另一种的简单点算法。

所有以上三种编码，base16，base32，以及base64都是为了在7位系统下（7-bit systems）安全点传输数据，避免数据损失的传输方式。传统Email系统就是一个7位系统，MIME的base64编码也是被设计成在系统间安全地传输数据的方法。总之，这三种编码方式都是为了避免8位数据在7位系统下的传输而设计的。

###工作原理

Base64编码直接作用于底层二进制数据。使用base64编码并不是直接编码字符串，而是编码字符串中代表字符的字节。字符串中的每个字节都是一个8位子节（byte），base64中编码的每个字符却是由6位构成的，除了将8位数据转换成6位，Base64编码并不做其它的操作。

在base64点字母表中有65中可能的字符， 字母A－Z，a－z，数字0-9以及加号（＋）和左斜杠（／）第65个字符是等于好（＝）它被用作表示填充（padding），关于填充到概念将在稍后讨论。因此在base64编码过的字符串中，6位（6-bit）数字0由字母A表示，相应地1由B表示，依次类推。

要使数据可被base64编码， 至少需要24位有效数据（被6和8整除的最小整数） 所以任何3个字符的ASCII序列（three-character ASCII sequence）都可以很好地在base64中编码。假设一个字符串“hat”。首字母“h”用104或者二进制01101000表示，“a”则是97或者01100001，而“t”则是116或者01110100，将他们放在一起，则是:  

    01101000-01100001-01110100
    
在base64编码中转换后，将会被重新定义边界，也就是转换成6位数据，如下：

    011010-000110-000101-110100
    
这之后， 将每个6位数据转换成数字则是：

    26-6-5-52
然后，用base64码表中的字符代替数字，则变成：

    a-G-F-0
所以在base64中编码后“hat”就是“aGFo”了。这样的运算可以很好地工作因为这里正好有24位有效数据，活着3个ASCII字符。由于并非所有的字符串都可以被3整除，所以base64编码需要填充不足位从而便于编码。


###填充

编码过程中将转换每个24位数据，知道没有梗长的数据可被转换。这时会出现以下三种情况：

- 没有更多的位可被转换（原字符串被3整除的情况下）。
- 剩下8位有效数据。这种情况将右填充0到12位。
- 剩下16位有效数据。这种情况将右填充0到18位。

注意以上第二和第三种情况，右填充只在最靠近被6整除的位数据地方。每个6位片段（segment）都被转换成一个字符，然后两个或一个等号（＝）就被分别添加到其后面。每个等号都表示右两个额外的位填充被添加。这些字符无法表示所有原始的ASCII字符串。他们只是简单表示处理位置的标识，以便解码器处理base64编码的字符串。

比如，单词“hatch”，字母“h”使用104或二进制01101000表示，“a”是97或者01100001，“t”则是116或者0110100，“c”是99或者01100011，“h”是104或者01101000，连起来就是：

    01101000-01100001-01110100-01100011-01101000
转换成base64编码，创建6位分组：

    (011010-000110-000101-110100)(011000-110110-1000)
注意该序列中只有第一部分是完整的24位数据（第一个小括号里的数据），序列的第二部分只有16位数据。这种情况下，第二个分组应该填充两个0位以便创建18位分组：

    (011010-000110-000101-110100)(011000-110110-100000)
然后6位分组转换成字符：

    (a-G-F-0)(Y-2-g)
所以结果字符串就是“aGFoY2g”。但这并非最终的base64编码字符串，由于存在两个填充位，一个等号必须添加到序列末尾，则结果为“aGFoY2g＝”